package pcsc

import (
	"bytes"
	"crypto/sha1"
	"fmt"
	"github.com/ProtonMail/go-crypto/openpgp/ecdh"
	"github.com/ProtonMail/go-crypto/openpgp/eddsa"
)

func computeGrip(key any) *[20]byte {
	switch v := key.(type) {
	case *eddsa.PublicKey:
		if v.GetCurve().GetCurveName() == "ed25519" {
			return computeED25519KeyGrip(v.X)
		}
	case *ecdh.PublicKey:
		if v.GetCurve().GetCurveName() == "curve25519" {
			return computeX25519KeyGrip(v.Point)
		}
	}
	return nil
}

func computeRSAKeyGrip(n []byte) *[20]byte {
	if n == nil || len(n) == 0 {
		return nil
	}
	var g [20]byte
	h := sha1.New()
	h.Write([]byte{0})
	h.Write(n)
	b := h.Sum(nil)
	copy(g[:], b)
	return &g
}

type rivestSExpPart struct {
	name  string
	value []byte
}

// computeRivestSExp computes Rivest's S-Expression for a given list of parts.
// https://datatracker.ietf.org/doc/draft-rivest-sexp/
func computeRivestSExp(parts []rivestSExpPart) *[20]byte {
	h := new(bytes.Buffer)
	for i := 0; i < len(parts); i++ {
		_, err := fmt.Fprintf(h, "(%d:%s%d:%s)", len(parts[i].name), parts[i].name, len(parts[i].value), parts[i].value)
		if err != nil {
			return nil
		}
	}
	grip := sha1.Sum(h.Bytes())
	return &grip
}

func computeX25519KeyGrip(key []byte) *[20]byte {
	if key == nil || len(key) != 32 {
		return nil
	}
	return computeRivestSExp([]rivestSExpPart{
		{name: "p", value: []byte{0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xed}},
		{name: "a", value: []byte{0x01, 0xdb, 0x41}},
		{name: "b", value: []byte{0x01}},
		{name: "g", value: []byte{0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x20, 0xae, 0x19, 0xa1, 0xb8, 0xa0, 0x86, 0xb4, 0xe0, 0x1e, 0xdd, 0x2c, 0x77, 0x48, 0xd1, 0x4c, 0x92, 0x3d, 0x4d, 0x7e, 0x6d, 0x7c, 0x61, 0xb2, 0x29, 0xe9, 0xc5, 0xa2, 0x7e, 0xce, 0xd3, 0xd9}},
		{name: "n", value: []byte{0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0xde, 0xf9, 0xde, 0xa2, 0xf7, 0x9c, 0xd6, 0x58, 0x12, 0x63, 0x1a, 0x5c, 0xf5, 0xd3, 0xed}},
		{name: "q", value: key},
	})
}

func computeED25519KeyGrip(key []byte) *[20]byte {
	if key == nil || len(key) != 32 {
		return nil
	}
	return computeRivestSExp(
		[]rivestSExpPart{
			{name: "p", value: []byte{0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xed}},
			{name: "a", value: []byte{1}},
			{name: "b", value: []byte{0x2d, 0xfc, 0x93, 0x11, 0xd4, 0x90, 0x01, 0x8c, 0x73, 0x38, 0xbf, 0x86, 0x88, 0x86, 0x17, 0x67, 0xff, 0x8f, 0xf5, 0xb2, 0xbe, 0xbe, 0x27, 0x54, 0x8a, 0x14, 0xb2, 0x35, 0xec, 0xa6, 0x87, 0x4a}},
			{name: "g", value: []byte{0x04, 0x21, 0x69, 0x36, 0xd3, 0xcd, 0x6e, 0x53, 0xfe, 0xc0, 0xa4, 0xe2, 0x31, 0xfd, 0xd6, 0xdc, 0x5c, 0x69, 0x2c, 0xc7, 0x60, 0x95, 0x25, 0xa7, 0xb2, 0xc9, 0x56, 0x2d, 0x60, 0x8f, 0x25, 0xd5, 0x1a, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x58}},
			{name: "n", value: []byte{0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0xde, 0xf9, 0xde, 0xa2, 0xf7, 0x9c, 0xd6, 0x58, 0x12, 0x63, 0x1a, 0x5c, 0xf5, 0xd3, 0xed}},
			{name: "q", value: key},
		})
}
